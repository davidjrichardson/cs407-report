\subsection{Implementation Outline}

Unity's design is based around Scenes. A Scene is a collection of all the objects which will impact the operation of the program. Unity has a strict "Component-Object Model", such that anything which is to act is an Object, and its operation is controlled by Components, which are scripts. There are a number of ways of inserting Objects into a Scene, and all of them are employed here.

\subsubsection*{Principal Objects}
The simplest way an Object is added to a scene is directly within the Unity editor. If this is done, the object will be within the Scene from the moment it is loaded. Any attached Components which have a \verb|Start()| function will have that function called on load. Our design had a number of Principal Objects:

\begin{itemize}
    \item \textbf{Player} - this Object contained the Camera, which decides where in the world to render, and the VR handsets. Components attached to the Player include dynamic input (detecting \verb|justPressed| and \verb|justReleased| states), and triggers for changing the current floor or bringing up the Menus.
    \item \textbf{Sun} - this Object represents the ambient lighting in the world. Changing properties on the Sun also changes the ambient lighting properties. This is an in-built feature of Unity.
    \item \textbf{Building} - contains both the Model (contained in scripts called \verb|Building|, \verb|Level|, ... ) and the View (\verb|BuildingRender|, \verb|LevelRender|, ... ). 
    \item \textbf{Blueprint} and \textbf{Grass} - these two are large flat objects which Unity calls Planes, though they are bounded rectangular meshes. They move in the XZ-plane with the player, to emulate an infinite plane. One represents the ground and remains at $y=0$. The other represents the floor of the current level and is located at $y=2 \times currentFloor$. The latter is used for raycasting when determining where the user is pointing.
\end{itemize}

\subsubsection*{Pre-built Objects}
Pre-built Objects, referred to in Unity as \textit{Prefabs}, are Objects which have been designed within the Editor but which have been saved out as individual files. These Prefabs can be loaded in at run-time, or saved to variables within the Editor. Loading a Prefab is a matter of calling \verb|Resources.Load("asset")|, and instantiating it with \verb|GameObject.Instantiate(resource)|. This adds an instance of the Prefab to the world.

Objects loaded in as Prefabs include:

\begin{itemize}
    \item \textbf{Tools and Save Menus} - When the respective controller button is pressed, the menus open relative to the current position and pose of the controller. When the menu is closed, the instance is deleted. As instantiating these objects is a relatively cheap operation, this is not an optimisation concern.
    \item \textbf{HighlightRender} - When selecting objects to delete, a highlight is placed around them. This highlight is added in as Prefab and then its properties are altered so that it encloses the object.
\end{itemize}

\subsubsection*{Dynamic Objects}

A Dynamic Object is one which is designed and instantiated at run-time. This tends to be best used for objects which are primarily one mesh, the size and shape of which is determined entirely by the user.

This technique is used mainly for the raw architecture - the walls, floors, and roofs. When one of these is to be added to the Scene, a plain GameObject is instantiated, and the Mesh is created in the abstract. It is then attached to a MeshRenderer and MeshCollider, which control the appearance and behaviour of the mesh. Any relevant Components can then be added, and the parent object of the architecture the \verb|Building| Object) can be set.

\section{Implemented tools}
\label{sec:tools}
To provide the full functionality, a number of tools were implemented hat the user can switch between during the running of the app. There are a total of 10 tools implemented that cover all the functionality of the app (except of loading and saving the scene which is handled through a separate menu):

\begin{enumerate}
    \item \textbf{Add Wall} - creates new segments of wall.
    \item \textbf{Remove Wall} - removes segments of walls, floors and objects from the scene.
    \item \textbf{Add Doorway} - creates cut-outs in the walls to create a space in which a door can be places.
    \item \textbf{Weather} - changes the lightning in the scene to simulate different times of day and different weather.
    \item \textbf{Draw Floor} - creates flat areas of arbitrary size that represent the floor segments.
    \item \textbf{Paint Floor} - changes the texture on a selected floor segment.
    \item \textbf{Add Object} - adds new objects to the scene.
    \item \textbf{Teleport} - teleport the user to the pointed location.
    \item \textbf{Paint Walls} - changes a colour of the wall.
\end{enumerate}

The user can change the tool they are using, by summoning the tool menu and selecting the new tool they want to start using. The tools are not linked to any specific hands, which means the user can arbitrary assign tools to different hands depending on the task they are doing.

\section{Object import}
The system was designed to allow the users to easily import their own furniture and other kind of objects into the program The system itself contains no hardcoded objects that can be placed in the scene, instead the user can place specially created files in \verb|main_Data\AssetBundles| directory in the installation location to import them into the program at runtime. This is implemented using Unity's AssetBundles~\cite{unity:assetbundle}, which are designed exactly for the purpose of storing a Unity files in a format that can be loaded by the application at run time.

In order to supply users with initial set of objects, a special button was added to the editor under the Assets menu to allow for a creation of a basic set of objects to be used within the game.

\section{Saving and loading a scene}
\label{sec:saving}
To allow the user to save and load the projects they've been working on, a save and load menu was implemented. This has been achieved using the serialisation method~\cite{unity:serialization}. The separation of model from view was used in this process as native Unity classes are not possible to serialise, which meant that only the underlying models were possible to easily serialise and write to a file. During the loading phase the models have to be replaced by the ones found in the file, and Unity specific objects need to be reconstructed from that model. The serialisation process creates a new file that is independent from the rest of the project and can be transferred between different machines, by copying the \verb|.sav| files between the \verb|projects| directories on different machines.

\section{Unity features in use}
Apart from the previously mentioned AssetBundles~\cite{unity:assetbundle} and the serialisation method~\cite{unity:serialization}, a number of other Unity methods were used to speed up the development process. An important feature here is the in-built ray casting in Unity that is used in all the tools to determine the object or the location the user is pointing at. A related feature to this are the layers, which allowed certain objects to be excluded when performing ray casting; this was mainly used in the Paint Floor tool to ignore the Blueprint object which was located above the floor segment and perform ray casting against floor segments only. Without the layers the ray casting would collide with the blueprint object (which was closer to the user) instead of the floor segments.

Unity's prefabs are used to store the objects that can be place-able in the scene The prefabs that are stored in the asset bundle are used to instantiate new Unity objects as a duplicate of the original object.

Another useful feature of Unity that was used in this project was Unity's support for distributing assets. The editor has an in build range of Standard Assets, some of which were imported into the project. Unity also has it's own assets store, which allows the developers to download 3rd party assets (including scripts, 3d models, textured and more) into their own project for free or for a fee.

% Expand on what Standart Aseets we used?

\section{Imported Assets}
To save us the trouble of creating 3D models to use in the program, two packages were downloaded from the Unity Asset Store and used in the project. Those packages were:
\begin{itemize}
    \item \textbf{Free Furniture Set} - a collection of wooden furniture, available at \url{https://www.assetstore.unity3d.com/en/#!/content/26678}
    \item \textbf{Gray Furniture Pack} - a collection of grey objects, both furniture and electronics, availible at \url{https://www.assetstore.unity3d.com/en/#!/content/40580} 
\end{itemize}

Those assets were available for free and the licencing allows them to be used in our project as discussed in section~\ref{sec:legal}.